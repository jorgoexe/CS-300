# CS-300
#Project Problem and Solution
The projects in this course involved designing and implementing data structures, such as linked lists, hash tables, and binary search trees, for practical applications. For example, in one project, I built a property auction bid management system using a binary search tree, which allowed efficient bid sorting, searching, and removal. In another project, I designed an advising assistance software for ABC University, using data structures to load, organize, and display course information based on prerequisites and alphanumeric ordering.

#Problem-Solving Approach and Importance of Data Structures
My approach focused on understanding how each data structure’s properties aligned with the project requirements. For instance, I chose binary search trees for bid management due to their efficiency in ordered data storage and retrieval. Understanding data structures was crucial because they directly impact how data is stored, accessed, and modified within a program, enabling me to create solutions that are efficient and scalable.

#Overcoming Challenges
Some challenges included managing key collisions in hash tables and implementing efficient data insertion and removal in binary search trees. I overcame these roadblocks by revisiting core concepts, exploring algorithm examples, and incrementally testing my code. This iterative testing approach helped identify bugs early and verify that each function performed as expected before moving on to the next.

#Expanded Approach to Software Design and Development
These projects expanded my approach to software design by emphasizing the importance of selecting the right data structure to meet specific program requirements. I now approach design with a stronger focus on performance considerations and how different structures affect runtime. Additionally, analyzing requirements in detail has become a primary step to ensure that my design choices align with project goals.

#Evolving Maintainable, Readable, and Adaptable Code Practices
Through these projects, I’ve improved my code organization and documentation practices. I prioritize clean, modular code, where each function has a clear purpose, and I use descriptive comments and naming conventions to enhance readability. The experience has underscored the value of maintainable code—code that is easy for others (or my future self) to read, modify, and expand—ensuring adaptability in evolving project requirements.

This reflection will serve as a helpful summary of my learning experiences and will be a valuable reference for similar projects in the future.
